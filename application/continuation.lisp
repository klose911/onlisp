;; 20 延续: 在运行中被暂停了的程序, 含有计算状态的单个函数型对象
;; 当这个对象被求值时，就会在它上次停下来的地方重新启动之前保存下来的计算
;; 表示挂起的进程, 表示搜索树中的节点 

;; 20.1 schem中的延续: 一个代表着计算的将来的函数

;; 把续延视为带一个参数的函数, 接下来的计算可以通过在返回值上调用这个函数来重现
;; (/ (- x 1) 2)中当求值 (- x 1) 时，外面的 / 表达式就在等着这个值， 以此类推，最后总是回到toplevel, print正等在那里
;; 表达式 (- x 1) 被求值时，续延将是：(lambda (val) (/ val 2))  

;; (define (f1 w)
;;   (let ((y (f2 w)))
;;     (if (integer? y) (list 'a y) 'b)))

;; (define (f2 x)
;;   (/ (- x 1) 2)) 
;; 表达式 (- x 1) 被求值时，续延将是:
;; (lambda (val)
;;   (let ((y (/ val 2)))
;;     (if (integer? y) (list 'a y) 'b)))

;; 在Scheme中，续延和函数同样是第一类对象
;; 你可以要求 Scheme 返回当前的续延，然后它将为你生成一个只有单个参数的函数，以表示未来的计算
;; 可以在任意长时间地保存这个对象，然后在你调用它时，将重启当它被创建时所发生的计算

;; 续延可以理解成是一种广义的闭包。闭包就是一个函数加上一些指向闭包创建时可见的词法变量的指针
;; 续延则是一个函数加上一个指向其创建时所在的整个栈的指针
;; 当续延被求值时，它返回的是使用自己的栈拷贝算出的结果，而没有用当前栈
;; 如果某个续延是在 T1 时刻创建的，而在 T2 时刻被求值，那么它求值时使用的将是 T1 时刻的栈!!!!! 

